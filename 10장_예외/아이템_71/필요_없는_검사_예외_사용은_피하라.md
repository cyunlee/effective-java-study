## item 71

### 필요 없는 검사 예외 사용은 피하라

---

### 🙋 검사 예외 사용을 왜 피해야 하나요?

검사 예외를 제대로 활용하면 `API`와 프로그램의 질을 높일 수 있습니다.
검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게끔 해주기 때문입니다.

그러나, 과하게 검사 예외를 사용하면 오히려 `쓰기 불편한 API가 됩니다.`
예시를 통해 알아보겠습니다.

#### 예시 상황) 어떤 메서드가 검사 예외를 던질 수 있다고 선언

- 문제 1) 사용자에게 부담을 줌
    - catch 블록을 두어 예외 처리 과정 필요
    - 더 바깥으로 던져 문제를 전파해야 함
- 문제 2) 검사 예외를 던지는 메서드는 `스트림 안에서 직접 사용할 수 없음`(아이템 45-48)

특히, 메서드가 `단 하나의 검사 예외만 던지는 경우`에는 사용자가 더욱 부담을 갖게 됩니다.
검사 예외가 단 하나뿐이라면, 오직 그 예외 때문에 API 사용자는 `try 블록을 추가해야 하`고, `스트림에서 직접 사용을 못하게 되`기 때문입니다.

따라서 `API를 제대로 사용해도 발생할 수 있는 예외`거나, `프로그래머가 의미 있는 조치를 취할 수 있는 경우`라면 괜찮지만,
둘 중 어디에도 해당하지 않는다면 비검사 예외를 사용하는 게 좋습니다.

---


### 🙋‍♀️ 검사 예외를 회피하는 방법은 무엇인가요?

#### 1) 적절한 결과 타입을 담은 옵셔널을 반환

검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환하면 됩니다. 단점은 예외가 발생한 이유를 알려주는 부가 정보는 담을 수 없다는 것입니다.

#### 2) 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 변경
첫 번째 메서드는 예외가 던져질지 여주를 boolean 값으로 반환합니다. 그리고 예외 발생 가능성이 없는 상태에서 메서드를 호출합니다.
```java
if(obj.actionPermitted(args)){
	obj.action(args);
} else {
    ... // 예외 상황에 대처한다.
}
```
다만 이 경우에는 상태 검사 메서드에 해당하기에 단점이 그대로 적용된다는 점을 주의해야 합니다.
즉, `외부 동기화 없이 여러 스레드가 동시에 접근할 수 있`거나 `외부 요인에 의해 상태가 변할 수 있`다면 해당 방식은 적절하지 않습니다. 호출 사이에 객체의 상태가 변할 수 있기 때문입니다.
또한 `actionPermitted` 메서드가 `action` 메서드의 작업 일부를 중복 수행해야 한다면 이는 되레 성능면에서 손해입니다.

#### 3) 프로그래머가 이 메서드의 성공을 확신하거나, 실패 시 스레드를 중단하길 원한다면 그대로 사용
다만, `obj.action(args);` 한 줄로 호출하는 것이 주로 사용될 것이라면 리팩토링하는 게 바람직합니다.
