# 스레드 안전성 수준을 문서화해라. 

API를 멀티스레드 환경에서도 안전하게 사용하려면 클래스의 스레드 안전성을 명확히 문서화해야 한다. 스레드 안전성은 다음과 같은 수준으로 나눌 수 있다.

### 1. 불변(Immutable)
이 클래스의 인스턴스는 마치 상수와 같아 외부 동기화가 필요 없다.
예시: `String`, `Long`, `BigInteger`  
애너테이션: `@Immutable`

### 2. 무조건적 스레드 안전
이 클래스는 수정 가능한 상태를 가지지만, 내부적으로 동기화를 처리하므로 추가적인 동기화 없이 멀티스레드 환경에서도 안전하다.
예시: 내부적으로 동기화를 처리한 클래스들
애너테이션: `@ThreadSafe`

### 3. 조건부 스레드 안전
기본적으로는 무조건적 스레드 안전 클래스와 유사하지만, 특정 메서드는 외부에서 별도의 동기화가 필요하다.  
예시: `Collections.synchronizedMap`이 반환한 컬렉션  
애너테이션: `@ThreadSafe`  
반드시 API 문서에 어떤 메서드 호출에서 어떤 락을 사용해야 하는지 명확히 명시해야 한다.

**예시:**
```java
Map<K, V> m = Collections.synchronizedMap(new HashMap<>());
Set<K> s = m.keySet();
synchronized(m) {
    for (K k : s)
        k.f();
}
```
이처럼 동기화 방식을 정확히 따르지 않으면 동작을 보장할 수 없다.

### 3. 스레드 안전하지 않음
이 클래스의 메서드들은 수정 가능하며, 동시 접근 시 외부에서 동기화를 반드시 수행해야 한다.
예시: `ArrayList`, `HashMap`  
애너테이션: `@NotThreadSafe`

### 4. 스레드 적대적
모든 메서드를 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다. 보통 정적 데이터를 동기화 없이 수정하는 경우에 해당한다.

### 명확한 API 문서화의 중요성
메서드 선언에 `synchronized` 키워드가 있다고 해서 자동으로 스레드 안전성이 보장되는 것은 아니다. 모든 클래스는 API 문서에 지원하는 스레드 안전성 수준과 필요한 동기화 방식을 명확히 명시해야 하며, 반환 객체의 스레드 안전성도 명시해야 한다.

### 올바른 락 사용법
공개된 락(예: `synchronized` 메서드)은 클라이언트 코드가 메서드 호출을 원자적으로 만들기 어렵게 하고, 서비스 거부 등의 문제가 발생할 수 있다. 이를 방지하기 위해 비공개 락 객체를 만들어 사용하는 것이 권장된다.

예시:
```java
private final Object lock = new Object();

public void someMethod() {
    synchronized(lock) {
        // 동기화된 작업 수행
    }
}
```
비공개 락 객체를 `final`로 선언하여 락 객체가 변경되는 상황을 방지해야 한다.

### 핵심 요약
모든 클래스는 자신의 스레드 안전성 정보를 명확히 문서화하고, 필요시 애너테이션(`@Immutable`, `@ThreadSafe`, `@NotThreadSafe`)을 통해 표기해야 한다.
특히 조건부 스레드 안전한 클래스는 사용자가 정확히 어떤 메서드에 어떤 방식으로 동기화해야 하는지 명확히 알려줘야 한다.

