# # 아이템 86. Serializable을 구현할지는 신중히 결정하라


정리
`Serializable` 을 구현하도록 클래스에 선언하면 직렬화 가능한 클래스가 된다. 매우 간단한 선언 방법과 다르게 구현한 대가는 매우 비싸다. 구현한 순간부터 많은 위험성을 갖게 되고 확장성을 잃게 된다.



## **Serializable 구현의 고려 사항**

### 1. **릴리즈 후 수정의 어려움**
- 직렬화 형태는 공개 API가 되며, 내부 구현 변경 시 호환성 문제가 발생할 수 있습니다. (원래의 직렬화 형태와 달라진다)
- **수정을 어렵게 만드는 요소**: SerialVersionUID가 자동 생성되면 수정 시 호환성이 깨질 수 있다.

### 2. **버그와 보안 취약성**
- 역직렬화는 생성자를 우회하여 객체를 생성하며, 불변식이 깨질 수 있고 보안 위험이 있습니다.
- 불변식이 깨진다 ?
    - 역직렬화는 생성자를 호출하지 않고 객체 생성. 이는 '숨은 생성자'로 불리며, 일반 생성자의 문제가 그대로 적용된다. 즉, 생성자에서 수행되는 초기화나 유효성 검사가 이루어지지않는다. 따라서, 역직렬화된 객체는 불변식이 깨질 수 있으며, 허가되지 않은 접근에 노출될 수 있다.

```java
public class Person implements Serializable {
    private final String name; // 불변 필드
    
    public Person(String name) {
        this.name = name;
        // 생성자에서 초기화 및 유효성 검사
        if (name == null) {
            throw new NullPointerException("Name cannot be null");
        }
    }
    
    // 역직렬화 시 생성자가 호출되지 않으므로, name이 null일 수 있음
}
```


### 3. **테스트의 복잡성 증가**
- 직렬화 가능한 클래스가 수정되면, 새로운 버전의 클래스가 구버전과 호환되는지 테스트해야한다.

### 4. **구현 여부의 신중한 결정**
- 클래스의 목적과 필요에 따라 구현 여부를 결정해야 한다.
- ex) BigInteger와 Instant 같은 ‘값’ 클래스와 컬렉션 클래스는 Serializable을 구현하였고 스레드 풀처럼 ‘동작’ 하는 객체를 표현한 클래스는 대부분 구현하지 않는다.

### 5. **구현하지 않는 경우**
- 상속 목적으로 설계된 클래스나 대부분의 인터페이스는 구현하지 않는 것이 좋다. 다만, 특정 프레임워크 요구에 따라 구현해야 할 수도 있다.

### 6. **내부 클래스의 직렬화** 구현X
- 내부 클래스는 직렬화를 구현하지 않는 것이 좋다. 단, 정적 멤버 클래스는 예외



### 참고

#### 위험성과 확장성 문제
1. **위험성**
- **보안 취약점**: 직렬화는 객체의 내부 상태를 외부에 노출시킬 수 있으며, 이는 보안 취약점으로 이어질 수 있다. 특히, 외부에서 제공된 직렬화된 데이터를 역직렬화할 때, 악의적인 코드가 실행될 수 있다.
- **캡슐화의 깨짐**: 직렬화는 객체의 내부 상태를 직접 접근할 수 있게 하므로, 캡슐화가 깨질 수 있다. 이는 객체의 불변성을 유지하기 어렵게 만든다.

2. **확장성의 손실**
- **클래스 수정의 어려움**: 직렬화된 클래스의 내부 구현을 변경하면 호환성 문제가 발생할 수 있어서 클래스의 확장성을 제한
- **버전 관리의 필요성**: 클래스의 버전을 관리하기 위해 `serialVersionUID`를 사용해야 하며, 이를 잘못 관리하면 호환성 문제가 발생할 수 있다

#### SerialVersionUID
- 직렬화와 역직렬화를 얘기할 때 빼놓을 수 없는 것이 **SerialVersionUID(이하 SUID)**
    - 직렬화할 때 선언이 없다면 자동으로 unique한 번호 생성하여 관리(클래스의 기본 해시값을 사용)
    - SUID는 직렬화와 역직렬화 과정에서 값이 서로 맞는지 확인한 후에 처리를 하기 때문에 이 값이 맞지 않다면 `InvalidClassException` 예외가 발생
      => 그러니 변경이 있을 때 역직렬화 과정에서 문제가 생길 수 있으므로 선언하는 것을 추천한다.

#### 동작 클래스는 `Serializable`을 구현하지 않는 이유
- 이러한 클래스는 주로 **동작**에 중점을 두고 있으며, **상태**보다는 **동작**이 중요하다.
- **동작의 일시성**
    - 이러한 클래스는 주로 동작의 일시성을 가지고 있으며, 특정 시점의 상태를 저장하는 것이 의미 X
- **상태의 복잡성
    - 스레드 풀과 같은 동작 중심의 클래스는 내부적으로 복잡한 상태를 가질 수 있습니다. 예를 들어, 스레드 풀은 현재 실행 중인 스레드, 대기 중인 작업 큐 등 다양한 상태를 관리합니다. 이러한 상태를 직렬화하는 것은 복잡하며, 의미가 있을 수 X
- **동작의 재현 불가**
    - 직렬화된 상태를 역직렬화하여 원래의 동작을 재현하는 것은 불가능할 수 있습니다. 예를 들어, 스레드 풀의 경우, 스레드가 실행 중인 작업을 저장하고 재개하는 것은 매우 어렵습니다.

```java
// BigInteger와 같은 '값' 클래스는 Serializable을 구현
public class BigInteger implements Serializable {
    // ...
}

// 스레드 풀과 같은 '동작' 클래스는 Serializable을 구현하지 않음
public class ThreadPoolExecutor {
    // ...
}

```
