# 객체는 인터페이스를 사용해서 참조해라

> 👉🏻 핵심 정리
>1. **가능하면 인터페이스 타입**으로 선언하여 **구현 교체**의 유연성을 극대화한다.
>2. **특정 구현 클래스의 고유 기능**에 의존하지 않는다면, 인터페이스만 알면 되므로 **코드 수정 범위**가 크게 줄어든다.
>3. 적절한 인터페이스가 **존재하지 않는다면**, 클래스 계층구조에서 **더 상위 클래스**로 선언하자.
>4. 다만,
    - `String`이나 `BigInteger` 같은 **값 클래스**
    - `OutputStream` 등 **추상 클래스 기반 객체**
    - **특별한 메서드를 제공**하는 클래스(PriorityQueue 등)  
      은 예외적으로 **클래스 타입**으로 사용해도 괜찮다.


`아이템 51 메서드 시그니처를 신중히 설계하라` 중 parameter type으로 class 대신 iterface를 
사용하라 라는 주제의 확장판!
위 내용을 확장하여 `객체는 클래스가 아닌 인터페이스로 참조하라`로 확장이 됨.

다시 한번 정리해봅시다!

| Interface                 | Class                                |
|---------------------------|-------------------------------------|
| 유연(Flexible)하다       | 형태가 고정적이다.                 |
| 어떤 구현체일지 알 수 없다. | 클래스가 명확하기 때문에 내부가 어떻게 이루어져 있는지 명확히 알 수 있다. |

###  적합한 인터페이스만 있다면 매개변수 뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라

객체의 실제 클래스를 사용해야 할 상황은 오직 생성자로 생성할 때 뿐!

👎나쁜예
```java
// 나쁜 예 - 클래스를 타입으로 사용
// 변경 전
LinkedHashSet<String> map = new LinkedHashSet<>();

// 변경 후
HashSet<String> map = new HashSet<>();
```
- 구현체 교체 시 타입 선언부 및 관련 코드 모두 수정 필요

- ArrayList 전용 메서드 사용 시 추가 수정 발생

👍좋은예
```java
// 좋은 예 - 인터페이스를 타입으로 사용
// 변경 전
Set<String> map = new LinkedHashSet<>();

// 변경 후
Set<String> map = new HashSet<>();

```
- List 인터페이스 메서드만 사용하면 구현체 교체 시 코드 수정 최소화

- ArrayList → LinkedList 변경 시 사용처 코드 영향 없음

나쁜 예의 코드는 컴파일 에러가 나거나 로직상에 문제가 있는 문제가 있는 코드느 아니다. 
But, 불편한 코드.
개발자가 LinkedHashSet을 사용하다가 HashSet으로 바꾼다고하면 전체를 위와 같은 예시로 변경해야함.
좋은예와 같은 경우 앞 선언 부분은 그대로 놔둔 채 구현 클래스만 바꿔주면 된다!


### 인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해진다.
나중에 구현 클래스를 교체하고자 한다면 새 클래스의 생성자 혹은 다른 정적 팩터리를 호출해주면 됨

### 주의해야할점
원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하며,
주변 코드가 이 기능에 기대어 동작한다면 새로운 클래스도 반드시 같은 기능을 제공해야 함!


예를 들어,

- **`LinkedHashSet`** 은 반복자의 순회를 **삽입 순서**대로 보장한다.
- 만약 코드가 이 순서 보장을 전제로 동작한다면, 이를 **`HashSet`** 으로 바꾸면 **순서가 보장되지 않아** 문제가 생긴다.

---

#### 구현 타입 변경의 동기

- **더 나은 성능**을 얻거나,
- **새로운 기능** (예: 순회 순서 보장, 키의 순서화 등)을 활용하기 위해서.

#### 예시

- `HashMap` → `EnumMap`
    - 키가 **열거 타입**일 때 가능
    - 더 빠른 속도, 정의된 순서대로 순회 가능
- `HashMap` → `LinkedHashMap`
    - 성능은 유사
    - **예측 가능한 순회 순서**를 제공

---

#### 구현 타입으로 변수를 선언했을 때의 문제

- “구현체도 바꿀 수 있으니, **처음부터 변수를 구현 타입으로 선언**해도 되지 않나?”라는 **오해**
- 기존 코드가 **기존 구현체에서만 제공하는 메서드**를 활용하거나,
- 다른 메서드가 **해당 구현 타입**을 인자로 받아야 하는 상황이면,
    - **새로 바꾼 구현체**로는 컴파일이 되지 않을 수 있음

---

#### 인터페이스 타입 선언의 이점

- 변수를 인터페이스 타입으로 선언하면,
    - **내부 구현체 교체의 영향**을 최소화할 수 있음
- “클라이언트는 인터페이스만 알고, 실제 구현은 몰라도 괜찮은” 구조
    - 추후 구현체 교체가 훨씬 수월

---

#### 결론

1. **코드가 특정 구현 클래스의 고유 기능에 의존하지 않는다면**,
    - 변수를 인터페이스 타입으로 선언하는 것이 **안전**하고 **유연**함.

2. **구현 클래스가 제공하는 특별한 기능을 반드시 사용해야 한다면**,
    - 그 의존 관계를 **명시적으로 인지**하고,
    - 새로운 클래스로 교체할 때 생길 수 있는 **호환성 문제**를 고려해야 함.

### 적합한 인터페이스가 없는 경우-> Class 타입으로

#### String, BigInteger 와 같은 값을 나타내는 Class
값 클래스가 여러 가지로 구현될 수 있다고 생각하고 설계하는 일은 거의 없음.
그러므로  final인 경우가 많고 상응하는 인터페이스가 별도로 존재하는 경우가 매우 드뭄
이러한 값 클래스 경우 매개변수, 변수, 필드, 반환 타입으로 사용해도 무방!

#### Class 기반으로 작성괸 framework가 제공하는 객체들 (ex. OutStream)
이런 경우라도 특정 구현 클래스보다는 (보통은 추상 클래스) 기반 클래스를 사용해 참조하는 것이 좋은 선택.
java.io 패키지 내부에는 BufferedOutputStream이나 FileOutputStream 등 여러 클래스가 존재하는데
이 경우에는 기반 클래스인 OutputStream을 사용할 수 있습니다.

#### Interface에 없는 특별한 메서드를 제공하는 클래스들(ex. PriorityQueue에는 없응 Comparator 메서드르르 제공)
PriorityQueue 클래스 경우 Queue 인터페이스에는 없는 comparator 메서드를 제공

cf)
참고 (PriorityQueue)
PriorityQueue 경우 Queue와 달리 우선순위에 따라 정렬하는 자료구조이다. 
따라서 정렬을 어떤 기준으로 할지 Comparator 인터페이스를 구현하고 있다.

```java
PriorityQueue<Integer> pq = new PriorityQueue<>((o1, o2) -> o2 - o1);
```

📌 다시 정리하자면...
- **적절한 인터페이스**가 있다면, 해당 인터페이스 타입으로 객체를 참조하자.
    - 이렇게 하면 클래스 구현을 자유롭게 교체할 수 있어서,
    - 코드가 **유연**해지고 **확장성**도 높아진다.

- 만약 쓸만한 인터페이스가 없다면,
    - 클래스 계층 구조에서 **더 상위**(덜 구체적인) 클래스를 타입으로 선택하자.
    - 불필요한 세부 구현에 얽매이지 않게 되어,
    - 코드가 더 **단단**하고 **유연**해진다.