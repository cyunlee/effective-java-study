## item 44

### 표준 함수형 인터페이스를 사용하라

---

```java
protected boolean removeEldestEntry(Map.Entry<K,V> eldest){
    return size() > 100;
}
```
위 코드는 `LinkedHAshMap` 클래스의 protected 메서드인 `removeEldestEntry` 메서드를
재정의한 것입니다. `이는 잘 동작하지만, 람다를 사용하면 훨씬 잘 해낼 수 있습니다!`

자바가 람다를 지원하면서 API를 작성하는 모범 사례도 크게 바뀌었기에,
위의 코드처럼 사위 클래스의 기본 메서드를 재정의해 원하는 동작을 구현하는 `템플릿 메서드 패턴`보다
같은 효과의 함수 객체를 받는 `정적 팩터리나 생성자 제공`으로 대체되고 있습니다.

람다는 단 하나의 추상 메서드를 가진 함수형 인터페이스를 구현할 때 사용됩니다.
따라서 위의 코드를 람다로 대체하기 위해 구현한 `표준 함수형 인터페이스`는 다음과 같습니다.

```java
@FunctionalInterface interface EldestEntryRemovalFunction<K,V>{
    // removeEldestEntry 에서 size 메서드를 사용하는데 이게 인스턴스 메서드라, 
    // 팩터리나 생성자를 호출할 때는 맵의 인스턴스가 존재하지 않음을 고려하여 인스턴스 전달 필요
    boolean remove(Map<K,V> map, Map.Entry<K,V> eldest);
}
```

---

### 🙌 위의 인터페이스도 잘 동작하지만, 굳이 사용할 이유는 없습니다.

왜냐면! 이미 같은 모양의 인터페이스가 준비되어 있기 때문입니다. 
java.util.function 패키지를 보면 다양한 용도의 표준 함수형 인터페이스가 담겨 있습니다.
따라서 `필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라` 고 합니다!

위의 코드의 경우, 직접 만든 `EldestEntryRemovalFunction` 대신, 
표준 인터페이스인 `BiPredicate<Map<K,V>, Map.Entry<K,V>>` 를 사용할 수 있습니다.

---

### 🙋‍♀️ 표준 함수형 인터페이스를 활용하는 것의 장점은 뭔가요?

1) API가 다루는 개념의 수 ↓ > 익히기 쉬움
2) 제공된 많은 디폴트 메서드 > 다른 코드와의 상호운영성 좋아짐
   - ex) `predicate` 인터페이스의 `predicate` 들을 조합하는 메서드 제공(`and()`, `or()`, `negate()` 등)
   <details> <summary>📌 predicate 조합 메서드</summary>

    | 메서드 | 설명 | 예제 |
    |--------|------|------|
    | `and(Predicate<T> other)` | 두 개의 Predicate를 AND 연산으로 조합 | `p1.and(p2)` |
    | `or(Predicate<T> other)` | 두 개의 Predicate를 OR 연산으로 조합 | `p1.or(p2)` |
    | `negate()` | 현재 Predicate의 결과를 반대로 반환 | `p1.negate()` |
    | `isEqual(Object targetRef)` | 주어진 객체와 같은지 검사하는 Predicate 반환 | `Predicate.isEqual("test")` |
    </details>

---

### 🙌 표준 함수형 인터페이스 기본 종류 6가지

이 기본 인터페이스들은 모두 참조 타입용입니다.

| 인터페이스          | 매개변수 | 반환값 | 설명                                              |
|------------------|--------|--------|-------------------------------------------------|
| `UnaryOperator<T>` | T      | T      | 인수가 1개인 것으로 반환값과 인수 타입이 같은 함수   |
| `BinaryOperator<T>` | (T, T) | T      |인수가 2개인 것으로 반환값과 인수 타입이 같은 함수 |
| `Predicate<T>`    | T      | boolean | 인수 1개를 받아 boolean을 반환하는 함수                      |
| `Function<T, R>`  | T      | R      | 인수와 반환 타입이 다른 함수                                |
| `Supplier<T>`     | 없음    | T      | 인수를 받지 않고 값을 반환(혹은 제공)하는 함수                     |
| `Consumer<T>`     | T      | 없음    | 인수를 하나 받고 반환값은 없는(인수를 소비하는) 함수                  |

위의 기본 인터페이스는 기본 타입인 int, long, double 용으로 각 3개씩 변형이 생겨납니다.
이름은 `BinaryOperator`에서 `LongBinaryOperator` 로 이름 앞에 해당 기본 타입 이름을 붙입니다.
이 변형들 중 유일하게 Function의 변형만 매개변수화 되었습니다. 
즉, Function 인터페이스의 기본 타입 변형만 제네릭이 아니라 구체적인 타입을 명시적으로 사용합니다.

---

### 🙋‍♀️ 왜 Function의 변형은 매개변수화 되는건가요?

`Function` 인터페이스는 입력과 출력의 타입이 다를 수 있기 때문에 그렇습니다!
`Function` 인터페이스는 기본 타입을 반환하는 변형이 9개가 존재합니다.
모두 기본 타입이라면, `SrcToResult` 로 `LongToIntFunction` 으로 진행합니다.(총 6개)
입력이 객체 참조이고 결과가 `int`, `long`, `double` 라면(총 3개), `ToLongFunction<int[]>` 로 `int[]` 인수를 받아 `long`을 반환한다는 것을 접두어로 `ToResult` 를 붙여 사용합니다.

---

### 🙌 기본 함수형 인터페이스 중 3개에는 인수를 2개씩 받는 변형이 있습니다.

`BiPredicate<T,U>` `BiFunction<T,U,R>` `BiConsumer<T,U>` 입니다.
1. BiPredicate<T, U>
    - 두 개의 입력(T, U)을 받아 boolean을 반환하는 함수입니다.
2. BiFunction<T, U, R>
   - 두 개의 입력(T, U)을 받아 하나의 결과(R)를 반환하는 함수입니다.
3. BiConsumer<T, U>
   - 두 개의 입력(T, U)을 받아 아무것도 반환하지 않는(소비하는) 함수입니다.

---

### 🙌 표준 함수형 인터페이스 사용 시, 주의점!!

표준 함수형 인터페이스 대부분이 기본 타입만 지원한다고, 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말아야 합니다.
동작은 하지만, 계산량이 많을 때는 성능이 처참히 느려질 수 있습니다.

---

### 🙋‍♀️구조적으로 똑같은 표준 함수형 인터페이스가 있더라도 직접 작성해야 하는 경우가 있나요?

예를 들어 `Comparator<T>` 인터페이스가 있습니다. 이는 구조적으로 `ToIntBiFunction<T,U>` 와 동일합니다.

그럼에도, 독자적인 인터페이스로 살아남아야 하는 이유는 다음과 같습니다.
1. API 에서 자주 사용되는데, 이름이 그 용도를 명확히 설명합니다.
2. 반드시 따라야 하는 규약을 담고 있습니다.
3. 유용한 디폴트 메서드를 듬뿍 제공하고 있습니다.

따라서, 다음과 같다면 전용 함수형 인터페이스를 구현해야 하는 건 아닌지 진중히 고민해야 합니다.

---

### 🙌 작성하는 게 인터페이스 임을 명심하고 주의해서 설계해야 합니다!!!

`@FunctionalInterface` 이 달려 있음에 주목해봅시다!
이 애너테이션을 사용하는 이유는 3가지 목적이 있습니다.
1. 해당 클래스의 코드나 설명 문서를 읽을 이에게 람다용으로 설계된 인터페이스라고 알려주는 것
2. 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되도록 설정하는 것
3. 2번의 결과로 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막음

따라서 꼭!! 해당 애너테이션을 사용해서 설계해야 합니다.

---

### 🙌 함수형 인터페이스 API 사용시 주의점

**서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의 X**

이유: 클라이언트에게 불필요한 모호함을 안겨 주며, 실제로 문제가 일어나기도 함
     - `ExecutorService` 의 경우, submit 메서드 내부에 `Callable<T>` 와 `Runnable`을 받는 것을 다중 정의 함
     - 그 결과 올바른 메서드를 알려주기 위해 형변환해야 할 때가 자주 생기는 문제 발생함
